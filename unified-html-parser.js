/**
 * Unified HTML Parser for E-commerce Sites
 * Extracts product names, location, and prices from HTML files generated by location-selector-orchestrator
 * Supports: D-Mart, JioMart, Nature's Basket, Zepto, and Swiggy Instamart
 * 
 * Usage:
 *   node unified-html-parser.js <html-file-path>
 *   node unified-html-parser.js outputs/dmart-mumbai-cookie-search-results.html
 * 
 * Or process all HTML files in outputs folder:
 *   node unified-html-parser.js outputs/
 */

import { readFileSync, readdirSync, statSync } from 'fs';
import * as cheerio from 'cheerio';
import * as path from 'path';

/**
 * Detects which site the HTML is from
 */
function detectSite(html, filename) {
  const htmlLower = html.toLowerCase();
  const filenameLower = filename.toLowerCase();
  
  if (htmlLower.includes('dmart.in') || filenameLower.includes('dmart')) {
    return 'dmart';
  } else if (htmlLower.includes('jiomart.com') || filenameLower.includes('jiomart')) {
    return 'jiomart';
  } else if (htmlLower.includes('naturesbasket.co.in') || filenameLower.includes('naturesbasket')) {
    return 'naturesbasket';
  } else if (htmlLower.includes('zepto.com') || filenameLower.includes('zepto')) {
    return 'zepto';
  } else if (htmlLower.includes('swiggy.com') || htmlLower.includes('instamart') || filenameLower.includes('swiggy')) {
    return 'swiggy';
  }
  return 'unknown';
}

/**
 * Extracts location from HTML based on site
 */
function extractLocation($, site, filename, html) {
  let location = null;
  
  // Try to extract location from filename first
  const filenameMatch = filename.match(/(mumbai|delhi|chennai|bangalore|hyderabad|pune|kolkata|ahmedabad|rt\s*nagar|rtnagar)/i);
  if (filenameMatch) {
    location = filenameMatch[1].charAt(0).toUpperCase() + filenameMatch[1].slice(1).toLowerCase();
    if (location.toLowerCase().includes('rt')) {
      location = 'RT Nagar';
    }
  }
  
  switch (site) {
    case 'dmart':
      // Try multiple selectors for D-Mart location
      location = location || $('.header_cityCntr__zUvCm').text().trim();
      if (!location || location === 'Mumbai') {
        // Check if there's a pincode that might indicate location
        const pincode = $('.header_title__h8YkR').text().trim();
        // Common pincode ranges: Mumbai (400xxx), Delhi (110xxx), Chennai (600xxx), Bangalore (560xxx)
        if (pincode) {
          if (pincode.startsWith('600')) location = 'Chennai';
          else if (pincode.startsWith('560')) location = 'Bangalore';
          else if (pincode.startsWith('110')) location = 'Delhi';
          else if (pincode.startsWith('400')) location = 'Mumbai';
        }
      }
      // Also try header_pincode class
      if (!location) {
        const pincodeText = $('.header_pincode__KryhE').text().trim();
        if (pincodeText) {
          location = pincodeText;
        }
      }
      break;
      
    case 'jiomart':
      // JioMart location is often in the delivery text
      const deliveryText = $('*').text();
      const locationMatch = deliveryText.match(/(?:delivery to|location|city)[:\s]+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/i);
      if (locationMatch) {
        location = locationMatch[1];
      } else {
        location = $('[data-testid*="location"]').text().trim() ||
                   $('.location, [class*="location"], [class*="city"]').first().text().trim() ||
                   $('span:contains("Location")').next().text().trim();
      }
      break;
      
    case 'naturesbasket':
      // Nature's Basket location extraction - avoid picking up "CART" or other UI elements
      // Try to find location in header or address elements, but exclude common UI text
      const naturesBasketLocationSelectors = [
        '[class*="address"]',
        '[class*="delivery"]',
        '[class*="location"]',
        '[class*="city"]'
      ];
      
      for (const selector of naturesBasketLocationSelectors) {
        const $elem = $(selector);
        $elem.each((i, el) => {
          const text = $(el).text().trim();
          // Filter out common UI elements
          if (text && text.length > 3 && text.length < 50 &&
              !text.match(/^(CART|Home|Menu|Search|Sign In|Login|Register|Your cart|Select)$/i) &&
              !text.includes('Your cart') && !text.includes('Select Location')) {
            location = text;
            return false; // break
          }
        });
        if (location) break;
      }
      break;
      
    case 'zepto':
      // Zepto location extraction - avoid picking up "Your cart is empty" or other UI elements
      // Try to find location in header or address elements
      const zeptoLocationSelectors = [
        '[class*="address"]',
        '[class*="delivery"]',
        '[class*="location"]',
        '[class*="city"]',
        '[data-location]'
      ];
      
      for (const selector of zeptoLocationSelectors) {
        const $elem = $(selector);
        $elem.each((i, el) => {
          const text = $(el).text().trim();
          // Filter out common UI elements
          if (text && text.length > 3 && text.length < 50 &&
              !text.match(/^(Your cart is empty|Cart|Home|Menu|Search|Sign In|Login|Register|Select)$/i) &&
              !text.includes('Your cart is empty') && !text.includes('Select Location')) {
            location = text;
            return false; // break
          }
        });
        if (location) break;
      }
      break;
      
    case 'swiggy':
      // Swiggy location is stored in JSON state - most reliable method
      try {
        const jsonMatch = html.match(/window\.___INITIAL_STATE___\s*=\s*({.+?});/);
        if (jsonMatch) {
          const state = JSON.parse(jsonMatch[1]);
          if (state.userLocation && state.userLocation.address) {
            location = state.userLocation.address;
          } else if (state.userLocation && state.userLocation.annotation) {
            location = state.userLocation.annotation;
          }
        }
        
        // Also check App.userLocation
        const appLocationMatch = html.match(/userLocation:\s*({[^}]+})/);
        if (appLocationMatch && !location) {
          try {
            const locationObj = JSON.parse(appLocationMatch[1]);
            if (locationObj.address) {
              location = locationObj.address;
            } else if (locationObj.annotation) {
              location = locationObj.annotation;
            }
          } catch (e) {
            // Try eval as fallback (less safe but sometimes needed)
            try {
              const locationObj = eval('(' + appLocationMatch[1] + ')');
              if (locationObj.address) {
                location = locationObj.address;
              } else if (locationObj.annotation) {
                location = locationObj.annotation;
              }
            } catch (e2) {
              // Continue to DOM extraction
            }
          }
        }
      } catch (e) {
        // JSON extraction failed, try DOM
      }
      
      // Fallback: Try DOM selectors
      if (!location) {
        const swiggyLocationSelectors = [
          '[class*="location"]',
          '[class*="address"]',
          '[class*="area"]',
          '[data-testid*="location"]',
          '[aria-label*="location"]',
          '[aria-label*="address"]'
        ];
        
        for (const selector of swiggyLocationSelectors) {
          const $elem = $(selector).first();
          if ($elem.length > 0) {
            const text = $elem.text().trim();
            if (text && text.length > 3 && text.length < 100 &&
                !text.match(/^(Search for an area or address|Select Location|Home|Cart|Menu)$/i)) {
              location = text;
              break;
            }
          }
        }
      }
      break;
  }
  
  return location || 'Unknown';
}

/**
 * Extracts products from D-Mart HTML
 */
function extractDmartProducts($) {
  const products = [];
  
  $('.vertical-card_card-vertical__Q8seS').each((index, element) => {
    const $card = $(element);
    
    // Extract product name
    const productName = $card.find('.vertical-card_title__pMGg9').text().trim();
    if (!productName) return;
    
    // Extract prices
    let mrp = null;
    let dmartPrice = null;
    let discount = null;
    
    $card.find('.vertical-card_price-container__tPCU9').each((i, priceEl) => {
      const $priceEl = $(priceEl);
      const label = $priceEl.find('.vertical-card_label__OOtAc').text().trim();
      const priceText = $priceEl.find('.vertical-card_amount__80Zwk').text().trim();
      const priceValue = parseFloat(priceText);
      
      if (label === 'MRP' && !isNaN(priceValue)) {
        mrp = priceValue;
      } else if (label === 'DMart' && !isNaN(priceValue)) {
        dmartPrice = priceValue;
      } else if (label === 'OFF' && !isNaN(priceValue)) {
        discount = priceValue;
      }
    });
    
    const isOutOfStock = $card.hasClass('vertical-card_no-stock__3G_E0') || 
                        $card.find('.vertical-card_info___ZmV_').text().includes('Out of Stock');
    
    products.push({
      name: productName,
      mrp: mrp,
      price: dmartPrice,
      discount: discount,
      discountAmount: mrp && dmartPrice ? mrp - dmartPrice : null,
      isOutOfStock: isOutOfStock
    });
  });
  
  return products;
}

/**
 * Extracts products from JioMart HTML
 */
function extractJioMartProducts($) {
  const products = [];
  
  // Common navigation/menu items to exclude
  const excludeTexts = ['Home', 'Shop By Category', 'My Orders', 'My List', 'Wishlist', 'Cart', 
                        'Sign In', 'Register', 'Login', 'Search', 'Menu', 'Categories'];
  
  // Try to find product cards - JioMart might use different structures
  // Look for elements that contain both product name and price
  $('div, article, section, li').each((index, element) => {
    const $elem = $(element);
    const text = $elem.text().trim();
    
    // Skip if it's too short or matches excluded navigation items
    if (text.length < 10 || excludeTexts.some(exclude => text === exclude || text.startsWith(exclude))) {
      return;
    }
    
    // Look for price indicators (â‚¹ symbol or price patterns)
    const hasPrice = $elem.find('*').text().match(/â‚¹\s*\d+|\d+\s*â‚¹|price|MRP|Rs\./i);
    if (!hasPrice) return;
    
    // Try to extract product name
    const productName = $elem.find('h1, h2, h3, h4, h5, h6, [class*="title"], [class*="name"]').first().text().trim() ||
                        $elem.find('a[href*="/p/"], a[href*="product"]').text().trim() ||
                        $elem.text().split('\n')[0].trim();
    
    if (!productName || productName.length < 3 || excludeTexts.includes(productName)) return;
    
    // Extract prices
    let mrp = null;
    let price = null;
    const priceText = $elem.text();
    const priceMatches = priceText.match(/â‚¹\s*(\d+(?:\.\d+)?)/g);
    
    if (priceMatches && priceMatches.length > 0) {
      const prices = priceMatches.map(m => parseFloat(m.replace(/[â‚¹\s]/g, ''))).filter(p => !isNaN(p) && p > 0);
      if (prices.length > 0) {
        // Usually the first price is MRP if there's a strikethrough, otherwise it's the selling price
        const hasStrike = $elem.find('s, del, [style*="line-through"], [class*="strike"]').length > 0;
        if (hasStrike && prices.length > 1) {
          mrp = prices[0];
          price = prices[1];
        } else {
          price = prices[0];
          if (prices.length > 1) mrp = prices[1];
        }
      }
    }
    
    // Calculate discount
    let discount = null;
    if (mrp && price) {
      discount = mrp - price;
    }
    
    // Only add if we have at least a product name and price
    if (productName && price) {
      products.push({
        name: productName,
        mrp: mrp,
        price: price,
        discount: discount,
        discountAmount: discount,
        isOutOfStock: $elem.find('[class*="out"], [class*="stock"], [class*="unavailable"]').length > 0
      });
    }
  });
  
  // Remove duplicates based on product name
  const uniqueProducts = [];
  const seenNames = new Set();
  for (const product of products) {
    const normalizedName = product.name.toLowerCase().trim();
    if (!seenNames.has(normalizedName) && product.name.length > 3) {
      seenNames.add(normalizedName);
      uniqueProducts.push(product);
    }
  }
  
  return uniqueProducts;
}

/**
 * Extracts products from Nature's Basket HTML
 */
function extractNaturesBasketProducts($) {
  const products = [];
  
  // Nature's Basket uses product links with h3 tags inside
  // Structure: <a href="/product-detail/..."><h3>Product Name</h3></a>
  $('a[href*="/product-detail/"]').each((index, element) => {
    const $link = $(element);
    
    // Extract product name from h3 tag inside the link
    const productName = $link.find('h3').first().text().trim() || 
                       $link.text().trim();
    
    if (!productName || productName.length < 3) return;
    
    // Find the parent container that likely contains price information
    const $container = $link.closest('div, article, section, li');
    
    // Extract prices from the container
    let mrp = null;
    let price = null;
    const containerText = $container.text();
    const priceMatches = containerText.match(/â‚¹\s*(\d+(?:\.\d+)?)/g);
    
    if (priceMatches && priceMatches.length > 0) {
      const prices = priceMatches.map(m => parseFloat(m.replace(/[â‚¹\s]/g, ''))).filter(p => !isNaN(p) && p > 0);
      if (prices.length > 0) {
        // Check for strikethrough (MRP) vs regular price
        const hasStrike = $container.find('s, del, [style*="line-through"], [style*="text-decoration: line-through"], [class*="strike"], [class*="line-through"]').length > 0;
        if (hasStrike && prices.length > 1) {
          // First price with strike is MRP, second is selling price
          mrp = prices[0];
          price = prices[1];
        } else if (prices.length > 1) {
          // If multiple prices, assume first is MRP, second is selling price
          mrp = prices[0];
          price = prices[1];
        } else {
          // Single price - assume it's the selling price
          price = prices[0];
        }
      }
    }
    
    // Check for out of stock - look for specific indicators, but be more careful
    // Don't mark as out of stock unless there's clear evidence
    const containerTextLower = containerText.toLowerCase();
    const isOutOfStock = $container.find('[class*="out-of-stock"], [class*="out_of_stock"], [class*="unavailable"], [class*="no-stock"]').length > 0 ||
                        (containerTextLower.match(/out of stock|currently unavailable|not available|sold out/i) !== null &&
                         !containerTextLower.match(/in stock|available/i));
    
    // Only add if we have a product name and price
    if (productName && price && productName.length >= 3) {
      let discount = null;
      if (mrp && price) {
        discount = mrp - price;
      }
      
      products.push({
        name: productName,
        mrp: mrp,
        price: price,
        discount: discount,
        discountAmount: discount,
        isOutOfStock: isOutOfStock
      });
    }
  });
  
  // Remove duplicates
  const uniqueProducts = [];
  const seenNames = new Set();
  for (const product of products) {
    const normalizedName = product.name.toLowerCase().trim();
    if (!seenNames.has(normalizedName) && product.name.length > 3) {
      seenNames.add(normalizedName);
      uniqueProducts.push(product);
    }
  }
  
  return uniqueProducts;
}

/**
 * Extracts products from Zepto HTML
 */
function extractZeptoProducts($) {
  const products = [];
  
  // Zepto uses data-slot-id="ProductName" for product names
  // Product names are also in img alt/title attributes
  // Structure: <div data-slot-id="ProductName" class="..."> or <img alt="Product Name" title="Product Name">
  
  // Strategy 1: Find products by img alt/title (primary method for Zepto)
  // Zepto products have product names in img alt/title attributes
  $('img[alt], img[title]').each((index, element) => {
    const $img = $(element);
    let productName = $img.attr('alt')?.trim() || $img.attr('title')?.trim();
    
    if (!productName || productName.length < 3) return;
    
    // Skip if it's not a product image (check for common non-product alt text)
    if (productName.match(/^(P3|Ad|logo|icon|button|arrow|close|menu|search|Zepto)$/i) || 
        productName.match(/\.(png|jpg|jpeg|gif|svg)$/i) || // Skip image filenames
        productName.length < 5) return;
    
    // Find the parent container - look for a div that contains both the img and price
    let $container = $img.parent();
    let depth = 0;
    const maxDepth = 5;
    
    // Walk up the DOM tree to find a container with price
    while (depth < maxDepth && $container.length > 0) {
      const containerText = $container.text();
      const hasPrice = containerText.match(/â‚¹\s*\d+/);
      
      if (hasPrice) {
        break; // Found a container with price
      }
      
      $container = $container.parent();
      depth++;
    }
    
    // If no container with price found, try siblings
    if (!$container.text().match(/â‚¹\s*\d+/)) {
      $container = $img.closest('div, article, section');
    }
    
    // Must have price in the container
    const hasPrice = $container.text().match(/â‚¹\s*\d+/);
    if (!hasPrice) return;
    
    // Extract prices
    let mrp = null;
    let price = null;
    const containerText = $container.text();
    const priceMatches = containerText.match(/â‚¹\s*(\d+(?:\.\d+)?)/g);
    
    if (priceMatches && priceMatches.length > 0) {
      const prices = priceMatches.map(m => parseFloat(m.replace(/[â‚¹\s]/g, ''))).filter(p => !isNaN(p) && p > 0);
      if (prices.length > 0) {
        const hasStrike = $container.find('s, del, [style*="line-through"], [class*="strike"]').length > 0;
        if (hasStrike && prices.length > 1) {
          mrp = prices[0];
          price = prices[1];
        } else if (prices.length > 1) {
          mrp = prices[0];
          price = prices[1];
        } else {
          price = prices[0];
        }
      }
    }
    
    // Check for out of stock
    const isOutOfStock = $container.find('[class*="out-of-stock"], [class*="unavailable"]').length > 0 ||
                        $container.text().match(/out of stock|currently unavailable/i) !== null;
    
    if (productName && price && productName.length >= 3) {
      let discount = null;
      if (mrp && price) {
        discount = mrp - price;
      }
      
      products.push({
        name: productName,
        mrp: mrp,
        price: price,
        discount: discount,
        discountAmount: discount,
        isOutOfStock: isOutOfStock
      });
    }
  });
  
  // Strategy 2: Fallback - Find product containers using data-slot-id
  if (products.length === 0) {
    $('[data-slot-id="ProductName"]').each((index, element) => {
      const $nameContainer = $(element);
      const $productCard = $nameContainer.closest('div, article, section, a');
      
      // Extract product name from the container or nearby img
      let productName = $nameContainer.text().trim();
      
      if (!productName || productName.length < 3) {
        productName = $productCard.find('img[alt]').first().attr('alt')?.trim() ||
                     $productCard.find('img[title]').first().attr('title')?.trim();
      }
      
      if (!productName || productName.length < 3) return;
      
      // Extract prices from the product card
      let mrp = null;
      let price = null;
      const cardText = $productCard.text();
      const priceMatches = cardText.match(/â‚¹\s*(\d+(?:\.\d+)?)/g);
      
      if (priceMatches && priceMatches.length > 0) {
        const prices = priceMatches.map(m => parseFloat(m.replace(/[â‚¹\s]/g, ''))).filter(p => !isNaN(p) && p > 0);
        if (prices.length > 0) {
          const hasStrike = $productCard.find('s, del, [style*="line-through"], [class*="strike"]').length > 0;
          if (hasStrike && prices.length > 1) {
            mrp = prices[0];
            price = prices[1];
          } else if (prices.length > 1) {
            mrp = prices[0];
            price = prices[1];
          } else {
            price = prices[0];
          }
        }
      }
      
      const isOutOfStock = $productCard.find('[class*="out-of-stock"], [class*="unavailable"]').length > 0 ||
                          $productCard.text().match(/out of stock|currently unavailable/i) !== null;
      
      if (productName && price && productName.length >= 3) {
        let discount = null;
        if (mrp && price) {
          discount = mrp - price;
        }
        
        products.push({
          name: productName,
          mrp: mrp,
          price: price,
          discount: discount,
          discountAmount: discount,
          isOutOfStock: isOutOfStock
        });
      }
    });
  }
  
  // Remove duplicates and filter out invalid products
  const uniqueProducts = [];
  const seenNames = new Set();
  for (const product of products) {
    const normalizedName = product.name.toLowerCase().trim();
    // Additional validation: product name should not be just numbers or special chars
    if (!seenNames.has(normalizedName) && 
        product.name.length >= 3 && 
        product.name.length < 200 &&
        !product.name.match(/^[\d\sâ‚¹\-]+$/) && // Not just numbers and symbols
        product.price > 0) {
      seenNames.add(normalizedName);
      uniqueProducts.push(product);
    }
  }
  
  return uniqueProducts;
}

/**
 * Extracts products from Swiggy Instamart HTML
 */
function extractSwiggyProducts($, html) {
  const products = [];
  
  // Exclude navigation and UI elements
  const excludedTexts = ['Careers', 'Swiggy One', 'Swiggy Instamart', 'Home', 'Cart', 'Search', 'Menu', 
                         'Login', 'Sign', 'Add', 'Remove', 'Quantity', 'View Cart', 'Checkout', 
                         'Delivery', 'Pickup', 'Filters', 'Sort', 'Categories', 'View All',
                         'See All', 'More', 'Less', 'Close', 'Back', 'Next', 'Previous'];
  
  // Strategy 1: Extract from JSON state (most reliable for Swiggy)
  try {
    let state = null;
    
    // Try multiple JSON extraction patterns
    const jsonMatch1 = html.match(/window\.___INITIAL_STATE___\s*=\s*(\{[\s\S]*?\n\s*\});/);
    if (jsonMatch1 && jsonMatch1[1]) {
      try {
        state = JSON.parse(jsonMatch1[1]);
      } catch (e) {
        // Try to extract with balanced braces
        const startIdx = html.indexOf('window.___INITIAL_STATE___ = {');
        if (startIdx !== -1) {
          let braceCount = 0;
          let inString = false;
          let escapeNext = false;
          let jsonStr = '';
          
          for (let i = startIdx + 'window.___INITIAL_STATE___ = '.length; i < html.length; i++) {
            const char = html[i];
            jsonStr += char;
            
            if (escapeNext) {
              escapeNext = false;
              continue;
            }
            
            if (char === '\\') {
              escapeNext = true;
              continue;
            }
            
            if (char === '"') {
              inString = !inString;
              continue;
            }
            
            if (!inString) {
              if (char === '{') braceCount++;
              if (char === '}') {
                braceCount--;
                if (braceCount === 0) {
                  try {
                    state = JSON.parse(jsonStr);
                    break;
                  } catch (e2) {
                    // Continue trying
                  }
                }
              }
            }
          }
        }
      }
    }
    
    // Pattern 2: Look for __NEXT_DATA__ or other JSON patterns
    if (!state) {
      const nextDataMatch = html.match(/<script[^>]*id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/);
      if (nextDataMatch && nextDataMatch[1]) {
        try {
          const nextData = JSON.parse(nextDataMatch[1]);
          if (nextData.props && nextData.props.pageProps) {
            state = nextData.props.pageProps;
          }
        } catch (e) {
          // Continue
        }
      }
    }
    
    if (state) {
      
      // Extract products from search results if available
      if (state.searchPLV2 && state.searchPLV2.data && state.searchPLV2.data.items) {
        state.searchPLV2.data.items.forEach(item => {
          if (item.name && item.price !== undefined) {
            products.push({
              name: item.name,
              price: item.price || item.finalPrice || null,
              mrp: item.mrp || item.originalPrice || null,
              discount: (item.mrp && item.price) ? item.mrp - item.price : null,
              discountAmount: (item.mrp && item.price) ? item.mrp - item.price : null,
              isOutOfStock: item.isOutOfStock || item.outOfStock || false
            });
          }
        });
      }
      
      // Extract from product listing if available
      if (state.categoryListingV2 && state.categoryListingV2.data && state.categoryListingV2.data.items) {
        state.categoryListingV2.data.items.forEach(item => {
          if (item.name && item.price !== undefined && !products.some(p => p.name === item.name)) {
            products.push({
              name: item.name,
              price: item.price || item.finalPrice || null,
              mrp: item.mrp || item.originalPrice || null,
              discount: (item.mrp && item.price) ? item.mrp - item.price : null,
              discountAmount: (item.mrp && item.price) ? item.mrp - item.price : null,
              isOutOfStock: item.isOutOfStock || item.outOfStock || false
            });
          }
        });
      }
      
      // Extract from campaign listing if available
      if (state.campaignListingV2 && state.campaignListingV2.data && state.campaignListingV2.data.items) {
        state.campaignListingV2.data.items.forEach(item => {
          if (item && item.name && item.price !== undefined && !products.some(p => p.name === item.name)) {
            products.push({
              name: item.name,
              price: item.price || item.finalPrice || null,
              mrp: item.mrp || item.originalPrice || null,
              discount: (item.mrp && item.price) ? item.mrp - item.price : null,
              discountAmount: (item.mrp && item.price) ? item.mrp - item.price : null,
              isOutOfStock: item.isOutOfStock || item.outOfStock || false
            });
          }
        });
      }
      
      // Try nested paths - more aggressive search
      const findProductsInObject = (obj, path = '', depth = 0) => {
        if (depth > 10 || !obj || typeof obj !== 'object') return; // Limit depth
        
        if (Array.isArray(obj)) {
          obj.forEach((item, idx) => {
            if (item && typeof item === 'object') {
              // Check if this looks like a product
              if (item.name && (item.price !== undefined || item.finalPrice !== undefined || item.sellingPrice !== undefined)) {
                if (!products.some(p => p.name === item.name)) {
                  products.push({
                    name: item.name,
                    price: item.price || item.finalPrice || item.sellingPrice || null,
                    mrp: item.mrp || item.originalPrice || null,
                    discount: (item.mrp && item.price) ? item.mrp - item.price : null,
                    discountAmount: (item.mrp && item.price) ? item.mrp - item.price : null,
                    isOutOfStock: item.isOutOfStock || item.outOfStock || false
                  });
                }
              } else {
                findProductsInObject(item, `${path}[${idx}]`, depth + 1);
              }
            }
          });
        } else {
          Object.keys(obj).forEach(key => {
            const keyLower = key.toLowerCase();
            if (keyLower.includes('product') || keyLower.includes('item') || 
                keyLower.includes('search') || keyLower.includes('listing') ||
                keyLower.includes('data') || keyLower.includes('result')) {
              findProductsInObject(obj[key], `${path}.${key}`, depth + 1);
            }
          });
        }
      };
      
      // Only do deep search if we haven't found products yet
      if (products.length === 0) {
        findProductsInObject(state);
      }
    }
  } catch (e) {
    // JSON extraction failed, continue with DOM extraction
    console.error(`Error extracting Swiggy JSON state: ${e.message}`);
  }
  
  // Strategy 2: DOM extraction - Look for data-testid attributes related to products
  if (products.length === 0) {
    $('[data-testid*="product"], [data-testid*="item-card"], [data-testid*="search-item"]').each((index, element) => {
      const $el = $(element);
      const productName = $el.find('[class*="title"], [class*="name"], h2, h3, h4').first().text().trim();
      
      // Validate product name
      if (productName && productName.length > 5 && 
          !excludedTexts.some(text => productName.includes(text)) &&
          !productName.match(/^(Home|Cart|Search|Menu|Login|Sign|Add|Remove|View|Checkout|Delivery|Pickup)$/i)) {
        
        let price = null;
        let mrp = null;
        
        // Look for price in the element
        const priceText = $el.text();
        const priceMatches = priceText.match(/â‚¹\s*(\d+[.,]?\d*)/g);
        if (priceMatches && priceMatches.length > 0) {
          const prices = priceMatches.map(m => {
            const match = m.match(/â‚¹\s*(\d+(?:[.,]\d+)?)/);
            return match ? parseFloat(match[1].replace(/,/g, '')) : null;
          }).filter(p => p !== null && p > 0);
          
          if (prices.length > 1) {
            // Usually first is MRP, second is selling price
            mrp = prices[0];
            price = prices[1];
          } else if (prices.length === 1) {
            price = prices[0];
          }
        }
        
        // Only add if we have a price (products should have prices)
        if (price !== null && !products.some(p => p.name === productName)) {
          products.push({
            name: productName,
            price: price,
            mrp: mrp,
            discount: mrp && price ? mrp - price : null,
            discountAmount: mrp && price ? mrp - price : null,
            isOutOfStock: $el.find('[class*="out-of-stock"], [class*="unavailable"]').length > 0 ||
                         $el.text().match(/out of stock|currently unavailable/i) !== null
          });
        }
      }
    });
  }
  
  // Strategy 3: Look for elements with price patterns and meaningful text
  if (products.length === 0) {
    $('div, section, article').each((index, element) => {
      const $el = $(element);
      const text = $el.text().trim();
      
      // Check if this element contains a price and meaningful product-like text
      if (text.match(/â‚¹\s*\d+/) && text.length > 10 && text.length < 200) {
        // Extract potential product name (text before price)
        const lines = text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        const priceLineIndex = lines.findIndex(l => l.match(/â‚¹\s*\d+/));
        
        if (priceLineIndex > 0) {
          const productName = lines[priceLineIndex - 1] || lines[0];
          
          // Validate it's a product name (not navigation, not too short)
          if (productName && productName.length > 5 && 
              !productName.match(/^(Home|Cart|Search|Menu|Login|Sign|Add|Remove|Quantity|View Cart|Checkout)$/i) &&
              !excludedTexts.some(text => productName.includes(text)) &&
              !products.some(p => p.name === productName)) {
            
            const priceMatches = text.match(/â‚¹\s*(\d+(?:[.,]?\d*)?)/g);
            let price = null;
            let mrp = null;
            
            if (priceMatches && priceMatches.length > 0) {
              const prices = priceMatches.map(m => {
                const match = m.match(/â‚¹\s*(\d+(?:[.,]?\d+)?)/);
                return match ? parseFloat(match[1].replace(/,/g, '')) : null;
              }).filter(p => p !== null && p > 0);
              
              if (prices.length > 1) {
                mrp = prices[0];
                price = prices[1];
              } else if (prices.length === 1) {
                price = prices[0];
              }
            }
            
            if (price !== null) {
              products.push({
                name: productName,
                price: price,
                mrp: mrp,
                discount: mrp && price ? mrp - price : null,
                discountAmount: mrp && price ? mrp - price : null,
                isOutOfStock: $el.find('[class*="out-of-stock"], [class*="unavailable"]').length > 0 ||
                             text.match(/out of stock|currently unavailable/i) !== null
              });
            }
          }
        }
      }
    });
  }
  
  // Remove duplicates
  const uniqueProducts = [];
  const seenNames = new Set();
  for (const product of products) {
    const normalizedName = product.name.toLowerCase().trim();
    if (!seenNames.has(normalizedName) && 
        product.name.length >= 3 && 
        product.name.length < 200 &&
        product.price !== null && product.price > 0) {
      seenNames.add(normalizedName);
      uniqueProducts.push(product);
    }
  }
  
  return uniqueProducts;
}

/**
 * Main extraction function
 */
function extractProductData(html, filename) {
  const $ = cheerio.load(html);
  const site = detectSite(html, filename);
  
  // Extract location (pass html for Swiggy JSON parsing)
  const location = extractLocation($, site, filename, html);
  
  // Extract products based on site
  let products = [];
  switch (site) {
    case 'dmart':
      products = extractDmartProducts($);
      break;
    case 'jiomart':
      products = extractJioMartProducts($);
      break;
    case 'naturesbasket':
      products = extractNaturesBasketProducts($);
      break;
    case 'zepto':
      products = extractZeptoProducts($);
      break;
    case 'swiggy':
      products = extractSwiggyProducts($, html);
      break;
    default:
      console.warn(`Unknown site detected, trying generic extraction...`);
      products = extractJioMartProducts($); // Fallback to generic extraction
  }
  
  return {
    site: site,
    location: location,
    products: products,
    totalProducts: products.length,
    filename: filename
  };
}

/**
 * Process a single HTML file
 */
function processHtmlFile(filePath) {
  try {
    console.log(`\nProcessing: ${filePath}`);
    const html = readFileSync(filePath, 'utf8');
    const filename = path.basename(filePath);
    const data = extractProductData(html, filename);
    return data;
  } catch (error) {
    console.error(`Error processing ${filePath}:`, error.message);
    return null;
  }
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    console.error('Usage: node unified-html-parser.js <html-file-path> [html-file-path2 ...]');
    console.error('   or: node unified-html-parser.js outputs/  (process all HTML files in outputs folder)');
    console.error('');
    console.error('Examples:');
    console.error('  node unified-html-parser.js outputs/dmart-mumbai-cookie-search-results.html');
    console.error('  node unified-html-parser.js outputs/');
    console.error('  node unified-html-parser.js outputs/*.html');
    process.exit(1);
  }
  
  const fsModule = await import('fs');
  const fs = fsModule.default || fsModule;
  const allResults = [];
  
  // Process each argument
  for (const arg of args) {
    const filePath = path.resolve(arg);
    const stats = fs.statSync(filePath);
    
    if (stats.isDirectory()) {
      // Process all HTML files in directory
      console.log(`\nðŸ“ Processing all HTML files in: ${filePath}`);
      const files = fs.readdirSync(filePath);
      const htmlFiles = files.filter(f => f.endsWith('.html'));
      
      if (htmlFiles.length === 0) {
        console.log(`âš ï¸  No HTML files found in ${filePath}`);
        continue;
      }
      
      for (const file of htmlFiles) {
        const fullPath = path.join(filePath, file);
        const result = processHtmlFile(fullPath);
        if (result) {
          allResults.push(result);
        }
      }
    } else if (stats.isFile() && filePath.endsWith('.html')) {
      // Process single file
      const result = processHtmlFile(filePath);
      if (result) {
        allResults.push(result);
      }
    } else {
      console.error(`âš ï¸  Skipping ${arg} (not an HTML file)`);
    }
  }
  
  if (allResults.length === 0) {
    console.error('âŒ No valid HTML files processed');
    process.exit(1);
  }
  
  // Display results
  console.log(`\n${'='.repeat(60)}`);
  console.log('EXTRACTION RESULTS');
  console.log('='.repeat(60));
  
  for (const result of allResults) {
    console.log(`\nðŸ“„ File: ${result.filename}`);
    console.log(`ðŸª Site: ${result.site.toUpperCase()}`);
    console.log(`ðŸ“ Location: ${result.location}`);
    console.log(`ðŸ“¦ Total Products: ${result.totalProducts}`);
    console.log('-'.repeat(60));
    
    // Display first 5 products as sample
    const displayCount = Math.min(5, result.products.length);
    result.products.slice(0, displayCount).forEach((product, index) => {
      console.log(`\n  [${index + 1}] ${product.name}`);
      if (product.mrp) console.log(`      MRP: â‚¹${product.mrp}`);
      if (product.price) console.log(`      Price: â‚¹${product.price}`);
      if (product.discountAmount) {
        console.log(`      Discount: â‚¹${product.discountAmount}${product.discount ? ` (${product.discount} OFF)` : ''}`);
      }
      if (product.isOutOfStock) console.log(`      Status: OUT OF STOCK`);
    });
    
    if (result.products.length > displayCount) {
      console.log(`\n  ... and ${result.products.length - displayCount} more products`);
    }
  }
  
  // Save to JSON
  const outputsDir = path.join(process.cwd(), 'outputs');
  if (!fs.existsSync(outputsDir)) {
    fs.mkdirSync(outputsDir, { recursive: true });
  }
  
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const jsonPath = path.join(outputsDir, `parsed-results-${timestamp}.json`);
  fs.writeFileSync(jsonPath, JSON.stringify(allResults, null, 2), 'utf8');
  console.log(`\n\nâœ… All results saved to: ${jsonPath}`);
  
  // Also save individual JSON files for each result
  for (const result of allResults) {
    const individualJsonPath = path.join(outputsDir, `${result.filename.replace('.html', '')}-parsed.json`);
    fs.writeFileSync(individualJsonPath, JSON.stringify(result, null, 2), 'utf8');
  }
  
  console.log(`âœ… Individual JSON files saved for each HTML file`);
  
  return allResults;
}

// Run if called directly
main().catch(console.error);

export { extractProductData, detectSite, extractLocation, extractDmartProducts, extractJioMartProducts, extractNaturesBasketProducts, extractZeptoProducts, extractSwiggyProducts };

